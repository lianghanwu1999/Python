#TODO 正则表达式
"""
入门：
#TODO 元字符：
.	匹配除换行符以外的任意字符
\w	匹配字母或数字或下划线或汉字
\s	匹配任意的空白符
\d	匹配数字
\b	匹配单词的开始或结束
^	匹配字符串的开始
$	匹配字符串的结束
例子：
\ba\w*\b匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。
\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。
\b\w{6}\b 匹配刚好6个字符的单词。
^匹配你要用来查找的字符串的开头，$匹配结尾 ：QQ号必须为5位到12位数字字符串时，可以使用：^\d{5,12}$

#TODO 字符转义：
1.使用\来取消这些字符的特殊意义。因此，你应该使用\.和\* ，要查找\本身，你也得用\\ 。
例如：deerchao\.cn匹配deerchao.cn，C:\\Windows匹配C:\Windows。

#TODO 重复（重复皆为前接单词）：
*	重复零次或更多次
+	重复一次或更多次
?	重复零次或一次
{n}	重复n次
{n,}	重复n次或更多次
{n,m}	重复n到m次

例如：Windows\d+匹配Windows后面跟1个或更多数字  ：Windows\d+1  = Windows 1 1 或 Windows 后加n个1
    ^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 重复一次 或无数次

字符类：
#TODO 任何 ：用方括号表示
[0-9]：可以匹配一个数字字符
[a-z] :字符范围。匹配指定范围内的任意一个字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意一个小写字母字符,出现多少次关键看后接符号。
匹配没有预定义元字符的字符集合：（方括号里列出它们就行）
匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u) 像[aeiou]就匹配任何一个英文元音字母
例如：[.?!]匹配标点符号(.或?或! 中的任何一个)
更复杂的表达式：\(?0\d{2}[) -]?\d{8}  可以表示匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等
解析：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着任意2个数字(\d{2})，
然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})  # \d{2} 表示任意两个数字

#TODO 分支条件  同样可以满足另一种（形成分支）
1.0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：
   一种是三位区号，8位本地号(如010-12345678)，同样可以是，一种是4位区号，7位本地号(0376-2233445)

#TODO 反义（字母大写有反义的效果）
\W	匹配任意不是字母，数字，下划线，汉字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

#TODO 后向引用 （前面写，后面引用）
后向引用步骤：先输入，后分组（组别，组名，再引用）
\b(\w+)\b\s+\1\b   ：\1 为组别1
设置组名：(?<Word>\w+)   这样就把\w+的组名指定为Word了
反向引用（捕获调用前面的内容）： \k<Word>
若完整的后向引用的为 ： <Word>\w+)\b\s+\k<Word>\b  ：组名为 word ，在利用\k<Word> 回调前面内容。

#TODO 分组语法（exp = 例子的意思，不是关键词，代码作为展示例子的几个数字）
捕获	    (exp)	         匹配exp,并捕获文本到自动命名的组里
            (?<name>exp)	 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
            (?:exp)	         匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言	(?=exp)	         匹配exp前面的位置    \b\w+(?=ing)	可以匹配I'm dancing中的danc
            (?<=exp)	     匹配exp后面的位置    (?<=\bdanc)\w+\b	可以匹配I love dancing and reading中的第一个ing
            (?!exp)	         匹配后面跟的不是exp的位置
            (?<!exp)	     匹配前面不是exp的位置
注释	    (?#comment)	     这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读

"""

#TODO python 使用正则表达式
"""
验证输入用户名和qq号是否有效并给出对应的提示信息
要求：用户名必须由字母，数字或下划线构成且长度在6-20个字符之间。qq好是5-12的数字且首位不能为0

"""
# import re #正则表达式模块
#
# #正则表达式应用1：匹配数字字符串和汉字。
#
# def main():
#     username = input('请输入用户名：')
#     qq = input('请输入qq号：')
#     #match 函数的第一个参数是正则表达式字符串或正则表达式对象
#     #第二个参数是要跟正则表达式做匹配的字符串对象
#     m1 = re.match(r'^[0-9a-zA_Z_]{6,20}$',username)  #可以匹配 [0-9a-zA_Z_] 匹配从0-9 a-z 和A-Z 的所有字符。
#     if not m1:
#         print('请输入有效的用户名.')
#     m2 = re.match(r'^[1-9]\d{4,11}$',qq)     #可以匹配数字 1-9 可以重复4-11次的字符串。
#     if not m2 :  #如果没有输入m2
#         print('请输入有效的qq号.')
#     if m1 and m2 :
#         print('你输入你的信息是有效的！')
#
# if __name__ == '__main__':
#     main()
#
# #TODO 例子2：从一段文字中提取出国内手机号码
# import re
#
# def main():
#     #创建正则表达式的对象 使用了 前瞻和后顾来保证手机号前后不应该出现的数字
#     pattern = re.compile(r'(?<=\D)1[34578]\d{9}(?=\D)')
#     #解析：匹配非数字的后面的位置，1 34578+9个随机数，匹配非数字的后面的位置
#     #例如：134578562562465335 (可以是：134578+9个随机数)
#     sentence = '''
#     重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，
#     不是15600998765，也是110或119，王大锤的手机号才是15600998765。
#     '''
#     #查找所有匹配并保存到一个列表中
#     mylist = re.findall(pattern,sentence)
#     print(mylist)
#     print('--------华丽的分隔线--------')
#     #通过迭代器取出匹配对象并获得匹配的内容
#     for temp in pattern.finditer(sentence):
#         print(temp.group())
#     print('--------华丽的分隔线--------')
#     #通过search函数指定搜索位置找出所有匹配
#     m = pattern.search(sentence)
#     while m :
#         print(m.group())
#         m = pattern.search(sentence,m.end())
#
# if __name__ == '__main__':
#     main()

# #TODO 例子3：替换字符串中的不良内容
# import re
#
# def main():
#     sentence = '你丫是傻叉吗? 我操你大爷的. Fuck you.'
#     purified = re.sub('[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔',
#                       '*', sentence, flags=re.IGNORECASE)  #flags参数，它代表了正则表达式的匹配标记，
#                         # 可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等
#     print(purified)   # 你丫是*吗? 我*你大爷的. * you.
#
# if __name__ == '__main__':
#     main()

#TODO  例子4：拆分长字符串
import re
def main():
    poem='床前明月光，疑是地上霜，举头望明月，低头思故乡。'
    sentence_list = re.split(r'[,。,.]]',poem)
    while '' in sentence_list:
        sentence_list.remove('')
    print(sentence_list)

if __name__ == '__main__':
    main()
